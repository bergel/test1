SystemOrganization addCategory: #YetAnotherGitIntegration!TestCase subclass: #YAGITest	instanceVariableNames: 'yagi'	classVariableNames: ''	poolDictionaries: ''	category: 'YetAnotherGitIntegration'!!YAGITest methodsFor: 'running' stamp: 'AlexandreBergel 9/27/2015 23:07'!setUp	yagi := YAGI new! !!YAGITest methodsFor: 'tests' stamp: 'AlexandreBergel 9/27/2015 23:14'!testBasic	yagi addPackageName: 'YetAnotherGitIntegration'.	yagi addPackageName: 'Kernel'.	self assert: yagi numberOfPackages equals: 2.		yagi addPackageRegexp: 'Announceme*'.	self assert: yagi numberOfPackages equals: 5! !!YAGITest methodsFor: 'tests' stamp: 'AlexandreBergel 9/27/2015 23:07'!testDefault	self assert: yagi numberOfPackages equals: 0! !MCTool subclass: #YAGI	instanceVariableNames: 'packages theGitFolder shellCommandLog'	classVariableNames: ''	poolDictionaries: ''	category: 'YetAnotherGitIntegration'!!YAGI class methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/27/2015 23:22'!menuCommandOn: aBuilder	<worldMenu>	((aBuilder item: #YAGI) icon: RTIcon smallRoassal)	withSeparatorAfter;	with: [		(aBuilder item: #'YAGI Browser')			order: 0.1; 			parent: #YAGI;			label: 'YAGI Browser';			action: [ self open ] ]! !!YAGI class methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/27/2015 23:03'!open	<script>	self new show! !!YAGI methodsFor: 'adding packages' stamp: 'AlexandreBergel 9/29/2015 14:24'!addPackage	"Called when adding a package"	| regexp |	regexp := UIManager default request: 'Enter a regular expression designating packages'.	regexp ifNil: [ ^ self ].	self addPackageRegexp: regexp! !!YAGI methodsFor: 'adding packages' stamp: 'AlexandreBergel 9/27/2015 23:09'!addPackage: aRPackage	self assert: [ aRPackage class == RPackage ] description: 'Only RPackage are allowed to be provided'.	packages add: aRPackage! !!YAGI methodsFor: 'adding packages' stamp: 'AlexandreBergel 9/27/2015 23:09'!addPackageName: aString	self addPackage: (RPackageOrganizer default packageNamed: aString)! !!YAGI methodsFor: 'adding packages' stamp: 'AlexandreBergel 9/28/2015 14:46'!addPackageRegexp: aString	self allPackageNames		do:			[ :aName | 			(aString match: aName)				ifTrue: [ self addPackage: (self getRPackageFromName: aName) ] ].	self changed: #packagesList! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 15:35'!addRepository	| creatingNewRepository |	creatingNewRepository := UIManager default chooseFrom: #('clone a GIT Repository' 'use an existing GIT Repository' 'setup a new GIT Repository') title: 'Do you want...'.	creatingNewRepository = 0 ifTrue: [ ^ self ].	(creatingNewRepository = 1)		ifTrue: [ self cloneGitRepository ].	(creatingNewRepository = 2)		ifTrue: [ self useExistingRepository ].	(creatingNewRepository = 3)		ifTrue: [ self setUpNewRepository ].	! !!YAGI methodsFor: 'private - package utility' stamp: 'AlexandreBergel 9/28/2015 14:46'!allPackageNames	^ RPackageOrganizer default packageNames! !!YAGI methodsFor: 'private - monticello utility' stamp: 'AlexandreBergel 9/29/2015 12:12'!allWorkingCopies	^ MCWorkingCopyBrowser new workingCopies! !!YAGI methodsFor: 'ui building' stamp: 'AlexandreBergel 9/28/2015 20:04'!buttonSpecs	^ #(#('+Package' #addPackage 'Add a new package')		#('Commit' #commit 'Commit all the packages')		#('Push' #push 'Push what is committed')		#('Pull' #pull 'Pull the repository')		#('+Repository' #addRepository 'Add a GIT repository')		#('Inspect' #inspect 'Inspect Yagi')		)! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 16:50'!cloneGitRepository	| existingFolder gitCloneUrl repositoryName gitFolder |	existingFolder := UIManager default		chooseDirectory:			'Please choose a location where to clone a GIT repository'.	existingFolder ifNil: [ ^ self ].	gitCloneUrl := UIManager default		request: 'Enter a GIT Clone URL'		initialAnswer:			'git@github.com:YOUR_USER_NAME/YOUR_PROJECT_NAME.git'.	gitCloneUrl ifNil: [ ^ self ].	self		shell: '/usr/bin/git clone ' , gitCloneUrl.	"Check if everything is alright"	repositoryName := self getProjectNameFromGitUrl: gitCloneUrl.	gitFolder := existingFolder / repositoryName.	gitFolder exists		ifFalse:			[ self error: 'Something wrong with the cloning'.			^ self ].	self useExistingRepository: gitFolder! !!YAGI methodsFor: 'git commands' stamp: 'AlexandreBergel 9/29/2015 14:04'!commit	| fileOutName wc newVersion definitions writer str comment saveOnSmalltalkHub reps repIndex |	theGitFolder ifNil: [ ^ UIManager default abort: 'Please, add a GIT repository' ].	self packageNames		do:			[ :packageName | 			wc := self getMCWorkingCopyForPackageName: packageName.			fileOutName := packageName , '.st'.			(wc needsSaving or: [ (theGitFolder / fileOutName) exists not ])				ifTrue: [ 					newVersion := wc newVersionIn: MCCacheRepository default.										saveOnSmalltalkHub := UIManager default question: 'Package ', packageName, ' is modified. You do want to save it on SmalltalkHub'.					saveOnSmalltalkHub ifNil: [ ^ self ].					saveOnSmalltalkHub ifTrue: [  						reps := wc repositoryGroup repositories.						"a MCRepositoryGroup"						repIndex := UIManager default chooseFrom: reps.						repIndex = 0 ifTrue: [ UIManager default abort: 'Nothing has been saved (both in git and in smalltalkhub'. ^ self ].						MCWorkingCopyBrowser new storeVersion: newVersion in: (reps at: repIndex).					]. 										definitions := newVersion snapshot definitions.					writer := MCStWriter new.					str := (theGitFolder / fileOutName) writeStream.					writer stream: str.					writer writeDefinitions: definitions.					str close.					self shell: '/usr/bin/git add ' , fileOutName ] ].	comment := UIManager default textEntry: 'Enter a comment ' title: ''.	comment ifNil: [ comment := '' ].	comment := comment copyReplaceAll: '"' with: '\"' asTokens: false.	self shell: '/usr/bin/git commit -m "' , comment , '"'! !!YAGI methodsFor: 'private - monticello utility' stamp: 'AlexandreBergel 9/29/2015 13:52'!getMCWorkingCopyForPackageName: packageName	"Return a Monticello Working copy for a given package name"	| workingCopies |	workingCopies := self allWorkingCopies.	^ workingCopies		detect: [ :workingCopy | workingCopy packageName = packageName ]! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 16:48'!getProjectNameFromGitUrl: gitCloneUrl	^ gitCloneUrl		copyFrom: (gitCloneUrl indexOf: $/) + 1		to: (gitCloneUrl indexOfSubCollection: '.git') - 1! !!YAGI methodsFor: 'private - package utility' stamp: 'AlexandreBergel 9/28/2015 14:45'!getRPackageFromName: aName	^ RPackageOrganizer default packageNamed: aName! !!YAGI methodsFor: 'initialization' stamp: 'AlexandreBergel 9/29/2015 14:15'!initialize	super initialize.	packages := OrderedCollection new.	theGitFolder := nil.	shellCommandLog := OrderedCollection new.	self registerToAnnouncer! !!YAGI methodsFor: 'metrics' stamp: 'AlexandreBergel 9/27/2015 23:05'!numberOfPackages	^ packages size! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 10:22'!packageNames	^ self packages collect: #packageName! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/27/2015 23:25'!packageSelection: anNumber	"Do nothing for now"! !!YAGI methodsFor: 'accessing' stamp: 'AlexandreBergel 9/27/2015 23:05'!packages	"Return the list of packages"	^ packages copy! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/29/2015 13:55'!packagesList	^ packages collect: [ :p | 		(self getMCWorkingCopyForPackageName: p packageName) needsSaving 			ifTrue: [ '*', p packageName ]			ifFalse: [ p packageName ] ]! !!YAGI methodsFor: 'initialization' stamp: 'AlexandreBergel 9/29/2015 13:41'!packagesListChanged	self changed: #packagesList.	"	self changedButtons."! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/27/2015 23:32'!packagesSelection	^ 0! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/27/2015 23:25'!packagesSelection: anNumber	"Do nothing for now"! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 17:22'!pull	self shellGit: 'pull'! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 17:22'!push	self shellGit: 'push'! !!YAGI methodsFor: 'initialization' stamp: 'AlexandreBergel 9/29/2015 13:39'!registerToAnnouncer	SystemAnnouncer uniqueInstance weak		when: MCPackageModified send: #update: to: self;		when: MCWorkingCopyCreated send: #update: to: self;		when: MCWorkingCopyDeleted send: #update: to: self! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 17:05'!setUpNewRepository	| a gitUrl projectName existingFolder |	a := UIManager default questionWithoutCancel: 'Have you created your project on Github or Bitbucket?'.	a ifFalse: [ 		UIManager default abort: 'Please, create an account on github.com and a repository', String cr, 'No need to initialize the repository, we can do it for you. Just get the address url that looks like git@github.com:YOUR_USERNAME/YOUR_PROJECT.git'.		^ self ].		gitUrl :=  UIManager default 							request: 'Enter a GIT Clone URL' 							initialAnswer: 'git@github.com:YOUR_USER_NAME/YOUR_PROJECT_NAME.git'.	gitUrl ifNil: [ ^ self ].		projectName := self getProjectNameFromGitUrl: gitUrl.	a := UIManager default proceed: 'You will now select a repository where the folder ', projectName, ' will be created'.	a ifFalse: [ ^ self ].		existingFolder := UIManager default chooseDirectory: 'Please choose a location where to create folder ', projectName.	 	existingFolder ifNil: [ ^ self ].	theGitFolder := (existingFolder / projectName).	theGitFolder exists ifFalse: [ theGitFolder createDirectory ].	a := UIManager default questionWithoutCancel: 'Have you initialized your project?E.g., Have you typed "git init" or "git push -u origin master"?If no, then relax, we will do it for you'.	a ifFalse: [ 		self shell: 'echo "# test1" >> README.md'.		self shell: 'git init'.		self shell: 'git add README.md'.		self shell: 'git commit -m "first commit"'.		self shell: 'git remote add origin ', gitUrl.		self shell: 'git push -u origin master'.	].	self useExistingRepository: theGitFolder! !!YAGI methodsFor: 'shell interaction' stamp: 'AlexandreBergel 9/29/2015 14:47'!shell: commandAsString	"Launch a command using OSProcess"	| string |	theGitFolder ifNil: [ self error: 'Should not be nil' ].	string := 'cd ' , theGitFolder fullName, ' && ', commandAsString.	shellCommandLog add: string.	^ OSProcess command: string! !!YAGI methodsFor: 'shell interaction' stamp: 'AlexandreBergel 9/28/2015 17:20'!shellGit: commandAsString	"commandAsString could be 'add blah.sh' or 'pull'"	^ self shell: '/usr/bin/git ', commandAsString! !!YAGI methodsFor: 'initialization' stamp: 'AlexandreBergel 9/29/2015 13:41'!update: anAnnouncement	self packagesListChanged.! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/28/2015 12:28'!useExistingRepository	| existingFolder |	existingFolder := UIManager default chooseDirectory: 'Please choose an existing Git repository'.		self useExistingRepository: existingFolder! !!YAGI methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 9/29/2015 14:05'!useExistingRepository: gitFolder		""	| t |	self assert: [ gitFolder class == FileReference ] description: 'You have to provide a FileReference'.		theGitFolder := gitFolder.	t := theGitFolder asString.	self window setLabel: 'YAGI: ...', (t copyFrom: t size - 10 to: t size).	"Looking for the packages"	gitFolder children do: [ :file | 		(file basename endsWith: '.st') ifTrue: [ 			"Will do something here"			] ]! !!YAGI methodsFor: 'ui building' stamp: 'AlexandreBergel 9/28/2015 15:23'!widgetSpecs	| searchBarOffset |		searchBarOffset := 30 + StandardFonts defaultFont height + 10.		^ {		{{#buttonRow}. {0. 0. 1. 0}. {0. 0. 0. 30.}} .		{{#listMorph:. #packages}. {0 . 0 . 1. 1}. {0. searchBarOffset+3. 0. 0.}}		}! !	}! !